"use strict";

require("core-js/modules/web.immediate.js");

var model = _interopRequireWildcard(require("./model.js"));

var _recipeView = _interopRequireDefault(require("./views/recipeView.js"));

var _searchView = _interopRequireDefault(require("./views/searchView.js"));

var _resultsView = _interopRequireDefault(require("./views/resultsView.js"));

var _paginationView = _interopRequireDefault(require("./views/paginationView.js"));

var _icons = _interopRequireDefault(require("url:../img/icons.svg"));

require("regenerator-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import icons from '../img/icons.svg'; //Parcel 1
//polyfilling everything else
//polyfilling async await
//?NOTE we use polyfilling to roll back ES6 features into older browsers that can't use it
if (module.hot) {
  module.hot.accept(); //?NOTE this is to freeze the state when the page reloads (it's not JS it is a parcel command)
}

const showRecipe = async function () {
  try {
    let id = window.location.hash.slice(1);
    console.log(id);
    if (!id) return;

    _recipeView.default.renderSpinner(); //* 1) Loading Recipe


    await model.loadRecipe(id); //* 2) Rendering Recipe

    _recipeView.default.render(model.state.recipe);
  } catch (error) {
    _recipeView.default.renderError();
  }
};

const controlSearchResults = async function () {
  try {
    //* 1) Get Search Query
    const query = _searchView.default.getQuery();

    if (!query) return; //* 2) Load Search Results

    await model.loadSearchResults(query); //?NOTE our model is imported and we call the loadSearchResults method and pass it the query we recieve from out getQuery method in our searchView
    //* 3) Render Results

    _resultsView.default.render(model.getSearchResultsPage()); //?NOTE now we are only passing the results in the array that were sliced out of the original array depending on what page the user is on into the render method to be rendered into the preview results
    //* 4) Render initial pagination buttons


    _paginationView.default.render(model.state.search);
  } catch (error) {
    console.error(error);
  }
};

const controlPagination = function (goToPage) {
  //* 1) Render NEW Results
  _resultsView.default.render(model.getSearchResultsPage(goToPage)); //* 2) Render NEW Pagination Buttons


  _paginationView.default.render(model.state.search);
};

const init = function () {
  _recipeView.default.addHandlerRender(showRecipe);

  _searchView.default.addHandlerSearch(controlSearchResults); //?NOTE these functions pass in functions to the methods in the views so they have access to them and can pass information back into this init() function

};

init();